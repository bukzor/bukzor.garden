# V0 Milestones Devlog

Ongoing log for Super Tic-Tac-Toe V0 development.

---

## 2026-02-03: Board Rendering

**Focus:** Basic 3x3 board rendering as foundation.

**Completed:**
- Board rendering with CSS Grid (3x3 grid, classic # lines)
- Restructured milestones: basic 3x3 first, then super-ify
- ADR for HTML+CSS rendering decision
- Clean separation: CSS in `style.css`, HTML generation in Rust
- Cell struct with position awareness and render method
- Data attributes (`data-row`, `data-col`) for CSS targeting

**Discovered:**
- CSS gap+background has subpixel issues at 1-2px; borders more reliable
- Inline `?` can confuse type inference with deref coercion; explicit bindings help
- Trunk `data-trunk` directives must stay in HTML (build-time)

**Decisions:**
- HTML+CSS over Canvas — see `docs/dev/adr/2026-02-03-000-htmlcss-rendering-for-super-tic-tac-toe.md`
- Start with basic 3x3, super-ify later

**Next:** Input handling (click/touch to place X/O)

---

## 2026-02-03 (cont'd): Ownership Simplification

**Conventions established:**

- **`&mut self` over functional style** — Functional (`fn method(self) -> Self`) forces `mem::replace` hacks to extract ownership from `RefCell`. Not worth it without undo/redo or snapshots.

- **Extract incidental complexity** — Helpers let you see the logic without the ceremony. Review test: does implementation detail match intent detail?

- **Don't store derivable data** — Data that duplicates its container's structure can lie (a `Square` at `[0][1]` claiming row 2). Delete it.

**Next:** Win detection

---

## 2026-02-04: Win Detection

**Focus:** Complete 3x3 tic-tac-toe with win/draw detection.

**Completed:**
- `Outcome` enum (InProgress, Win(Mark), Draw) with Debug derive
- Const-generated `WINNING_LINES` array via `winning_lines()` const fn
- `check_winner()` checks all 8 lines, `is_full()` detects draws
- `play()` updated: early-exit if game ended, set outcome, clear `current_turn` to Empty
- Status element above board shows "X wins!" / "O wins!" / "Draw!"
- CSS for status with `min-height` to prevent layout shift

**Decisions:**
- Const fn over literal array for winning lines — easier to verify correctness (pattern vs 24 coordinates)
- `current_turn = Mark::Empty` after game ends — semantically honest ("no one's turn")
- Direct field access for `outcome` instead of getter — no abstraction until earned
- Status element passed to click handler (option 1 from plan review)

**Next:** Super-ify (3x3 → 9x9 meta-grid)

---

## 2026-02-04 (cont'd): 9x9 Meta-Grid

**Focus:** Expand from 3x3 to 9x9 (3x3 meta-grid of 3x3 sub-boards).

**Completed:**
- `SubBoard` struct with `cells: [[Mark; 3]; 3]` and `outcome: Outcome`
- `Game.boards: [[SubBoard; 3]; 3]` replaces flat `board`
- Nested rendering: `render_board` → `render_sub_board` → `render_cell`
- 4 data attributes per cell (`data-meta-row/col`, `data-row/col`)
- CSS: thick borders (5px) between sub-boards, thin (2px) within, 10px padding

**Decisions:**
- `SubBoard` struct over 4D array — sub-boards need their own `outcome` for meta-game
- `grid-template-columns: auto` over `1fr` — prevents cell gaps when grid expands
- Padding inside sub-boards, not gap between — keeps meta-grid lines touching

**Next:** Sub-board win indicator (visual feedback when a sub-board is won)

---

## 2026-02-04 (cont'd): Sub-board Win Indicator

**Focus:** Visual feedback when a sub-board is won or drawn.

**Completed:**
- `.outcome` element always present in each sub-board (invariant position)
- Absolutely positioned overlay dims the board when resolved
- Wins show large X/O symbol; draws show only the dim
- `data-resolved` attribute controls visibility (`:empty` doesn't work for draw case)

**Decisions:**
- Overlay always exists vs conditional creation — avoids DOM churn on state change
- Named `.outcome` not `.overlay` — name represents what it is, not what it does
- Boolean `data-resolved` attribute vs class — semantic, CSS selector `[data-resolved]`

**Next:** Active sub-board constraint (the defining Super TTT mechanic)

---

## 2026-02-04 (cont'd): Active Sub-board Constraint

**Focus:** The defining Super TTT mechanic—your move determines opponent's target.

**Completed:**
- `active_board: Option<(usize, usize)>` tracks constraint (`None` = play anywhere)
- `play()` enforces constraint, sets next target based on cell position
- If target sub-board resolved, constraint clears (free choice)
- Grey dim overlay (`data-constrained`) on non-playable boards
- White dim (`data-resolved`) for completed boards (distinct visual)

**Decisions:**
- Renamed `.outcome` → `.status`, `.status` → `.final-status` — single overlay element serves both resolved and constrained states
- Navigate DOM (cell → sub-board → board) instead of cloning board_el into closure — avoids double-clone
- Grey vs white dim distinguishes "not allowed" from "complete"

**Next:** AI opponent (minimax)

---

## 2026-02-04 (cont'd): Rational Code Principle

**Focus:** Started auto-play feature, stopped to address irrational object model.

**Problem discovered:**

While implementing auto-play checkboxes (a test harness for AI), the code structure became visibly irrational:
- `Game` struct held `boards`, `current_turn`, `active_board` — but "board" doesn't know whose turn it is; games do
- `App` struct held `game`, `board_el`, `final_status` — but these are UI concerns, not "app" concerns
- Names didn't match contents; contents didn't match names

**Principle: Rational Code**

Code is rational when:
1. Things are named by what they represent
2. Attributes match what the name suggests should be owned
3. Methods match what the name suggests something can "do"

Irrational code *works* but *lies*. A `Board` with `current_turn` claims to be a board while actually being a game. This creates cognitive friction: readers must maintain a mental translation layer.

**Decision:**

Abandoned auto-play WIP (`archive/auto-play-wip-2026-02-04`) to refactor first. New structure:

| Type | Is | Owns | Does |
|------|----|------|------|
| **Board** | Physical 9x9 state | sub_boards, outcome | — |
| **Game** | Rules + state | board, current_turn, active_sub_board | play, legal_moves |
| **Ui** | DOM bindings | game, board_el, status_el, auto_play | handle_click, schedule_auto_play |
| **App** | WASM entry point | Rc\<Ui\>, listener | — |

Each layer has one job: data → logic → UI → glue.

**Rationale:**

A refactor that *only* improves clarity isn't always worth it. But this one also:
- Removes confusion about where new code belongs
- Makes the auto-play feature straightforward to add
- Sets up clean boundaries for future features (undo, themes, AI)

**Next:** Execute refactor per `.claude/todo.kb/2026-02-04-000-refactor-object-model-board-game-ui-app.md`

---

## 2026-02-04 (cont'd): Object Model Refactor Complete

**Focus:** Execute the Board/Game/Ui/App separation planned in previous session.

**Completed:**

Two-step refactor with working commits between:

1. **Board/Game separation** (48fdfb4)
   - Renamed `Game` → `Board` (pure physical state: sub_boards, outcome)
   - Created new `Game` (logic: board, current_turn, active_sub_board, play())
   - `Game.outcome` → `Board.outcome` (visible state)
   - `Game.active_board` → `Game.active_sub_board`

2. **Ui/App separation** (71af30a)
   - Created `Ui` struct (game RefCell, board_el, final_status)
   - `handle_click()` moved from free function into `Ui` method
   - `App` now thin wasm glue: holds `Rc<Ui>` and `_listener`
   - Removed unused `Game::shared()`

**Result:**

```
SubBoard  →  cells, outcome           (3x3 data + logic)
Board     →  sub_boards, outcome      (9x9 physical state)
Game      →  board, turn, constraint  (rules + play logic)
Ui        →  game, board_el, status   (DOM + click handling)
App       →  Rc<Ui>, listener         (wasm entry point)
```

Each type's name now matches what it contains.

**Next:** AI opponent (minimax) with auto-play checkboxes as test harness

---

## 2026-02-05: Auto-Play Test Harness + Polish

**Focus:** Random auto-play as foundation for AI work; game-end polish.

**Decisions:**

- **Programmatic click over direct `play()` call** — reuses the click handler instead of duplicating the update-DOM-after-move logic. One code path for all moves.
- **Test harness before intelligence** — random auto-play validates the scheduling/UI plumbing. Minimax plugs in later by replacing `pick_random` with a smarter selection.
- **Resolve unfinished boards on game end** — without this, won games leave stale constraint overlays on boards that were never played. Visual closure matters.
- **Slower transitions (0.3–0.4s)** — 0.15–0.2s felt instant/mechanical. Slightly slower gives the eye time to track what changed.

**Conventions:**

- `handle_click` takes `self: &Rc<Self>` — any method that schedules async work (timers, callbacks) needs owned `Rc` access. This is the pattern going forward.
- `App._listeners: Vec<EventListener>` — single listener field doesn't scale. Vec from here on.

